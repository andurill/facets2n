readSnpMatrix <- function(pileupfilename, skip=0L, err.thresh=Inf, del.thresh=Inf, 
                          perl.pileup=FALSE, MandUnormal=FALSE, spanT=0.2,
                          spanA=0.2, spanX=0.2, gbuild="hg19", 
                          ReferencePileupFile=NULL, ReferenceLoessFile=NULL,
                          MinOverlap=0.90, matchedNormalforX = FALSE) {
  #' readSnpMatrix takes a snp-pileup generated pileup file and optional pileup and loess data for reference normals and returns depth of select samples based on matched or unmatched analysis.
  #' @param skip (character) Skip n number of lines in the input file.
  #' @param err.thresh (numeric) Error threshold to be used to filter snp-pileup data frame.
  #' @param del.thresh (numeric) Deletion threshold to be used to filter snp-pileup data frame.
  #' @param perr.pileup (logical) Is the pileup data generated using perl pileup tool?
  #' @param MandUnormal (logical) Is CNLR analysis to be peformed using unmatched reference normals?
  #' @param spanT (numeric) Default span value to be used for loess normalization in tumor sample.
  #' @param spanA (numeric) Default span value to be used for loess normalization across autosomal chromosomes in the normal sample.
  #' @param spanX (numeric) Default span value to be used for loess normalization in Chr X in the normal sample.
  #' @param gbuild (character) Genome build (Default: hg19).
  #' @param ReferencePileupFile (character) Filepath to an optional snp-pileup generated pileup data of one or more reference normals.
  #' @param ReferenceLoessFile (character) Filepath to an optional loess data, generated using the facets2n package, of one or more reference normals. The number of normals in this data should match that in the ReferencePileupFile, and should be in the same order.
  #' @param MinOverlap (numeric) Mininum overlap fraction of loci between a tumor pileup and reference pileup data.
  #' @param matchedNormalforX (logical) Is the matched normal to be used for ChrX normalization?
  #' @return A dataframe of pileup depth values for Tumor and Matched Normal if MandUnormal is FALSE. Else, a list of data frame with pileup depth values of Tumor, matched Normal, and a best unmatched normal, and the associated span values.
  
  # could have been generated by original VES snp-pileup.pl code (perl)
  if (perl.pileup) {
    rcmat <- scan(pileupfilename, what=list(Chromosome="", Position=0, 
                                      NOR.DP=0, NOR.RD=0, TUM.DP=0, 
                                      TUM.RD=0), skip=skip)
    if (rcmat$Chromosome[1] == "chr1") {
      rcmat$Chromosome <- gsub("chr","",rcmat$Chromosome)
    }
    rcmat <- as.data.frame(rcmat, stringsAsFactors=FALSE)
  }
  else {
    # read the read count matrix generated by snp-pileup.cpp code
    tumor.pileup <- PreProcSnpPileup(pileupfilename, err.thresh=Inf, 
                               del.thresh=Inf, is.TandMN=T)
    if (MandUnormal) {
      tumor.loess <- MakeLoessObject(tumor.pileup, is.TandMN=T)
      reference.loess <- NULL
      reference.pileup <- NULL
      if (!is.null(ReferencePileupFile)) {
        reference.pileup <- PreProcSnpPileup(ReferencePileupFile, err.thresh=Inf, 
                               del.thresh=Inf, is.TandMN = F)
      }
      if(!is.null(ReferenceLoessFile)) {
        reference.loess <- as.matrix(read.csv(ReferenceLoessFile, sep="\t", 
                               stringsAsFactors=FALSE, header=T))
      }
      rcmat <- FindBestNormalParameters(
        tumor.loess,
        tumor.pileup,
        reference.loess,
        reference.pileup,
        MinOverlap,
        matchedNormalforX
      )
      return(rcmat)    
    }
    else {
      rcmat <- subset(tumor.pileup, select=c(Chromosome, Position, File1DP, File1R, File2DP, File2R))
      colnames(rcmat) <- c("Chromosome", "Position", "NOR.DP", "NOR.RD", "TUM.DP", "TUM.RD")
      return(rcmat)
    }
  }
}


preProcSample <- function(rcmat, ndepth=35, het.thresh=0.25, snp.nbhd=250, cval=25, deltaCN=0, gbuild=c("hg19", "hg38", "hg18", "mm9", "mm10"), hetscale=TRUE, unmatched=FALSE, MandUnormal=FALSE, ndepthmax=5000, spanT=0.2, spanA=0.2, spanX=0.2) {
  gbuild <- match.arg(gbuild)
  # integer value for chromosome X depends on the genome
  if (gbuild %in% c("hg19", "hg38", "hg18")) nX <- 23
  if (gbuild %in% c("mm9", "mm10")) nX <- 20
  pmat <- procSnps(rcmat, ndepth, het.thresh, snp.nbhd, gbuild, unmatched, ndepthmax)
  dmat <- counts2logROR(pmat[pmat$rCountT>0,], gbuild, unmatched, MandUnormal, 0.2, spanT,spanA, spanX)
  tmp <- segsnps(dmat, cval, hetscale, deltaCN)
  out <- list(pmat=pmat, gbuild=gbuild, nX=nX)
  c(out, tmp)
}


procSample <- function(x, cval=150, min.nhet=15, dipLogR=NULL) {
  # ensure availability of seg.tree
  if (is.null(x$seg.tree)) stop("seg.tree is not available")
  # get the numeric value of chromosome X
  nX <- x$nX
  # make sure that original cval is smaller than current one
  cval.fit <- attr(x$seg.tree, "cval")
  if (cval.fit > cval) stop("original fit used cval = ", cval.fit)
  # jointseg etc
  jseg <- x$jointseg
  jseg <- jseg[is.finite(jseg$cnlr),]
  # chromosomes with data and their counts
  chrs <- x$chromlevels
  nchr <- length(chrs)
  # get chromlevels from chrs
  if (x$gbuild %in% c("hg19", "hg38", "hg18")) chromlevels <- c(1:22,"X")[chrs]
  if (x$gbuild %in% c("mm9", "mm10")) chromlevels <- c(1:19,"X")[chrs]
  # get the segment summary for the fit in seg.tree
  nsegs <- 0
  for (i in 1:nchr) {
    seg.widths <- diff(c(0, sort(unique(x$seg.tree[[i]][,3]))))
    jseg$seg[jseg$chrom==chrs[i]] <- nsegs + rep(1:length(seg.widths), seg.widths)
    nsegs <- nsegs + length(seg.widths)
  }
  focalout <- jointsegsummary(jseg)
  # cnlr.median to the left and right
  cnlr.med.l <- c(0, focalout$cnlr.median[-nsegs])
  cnlr.med.r <- c(focalout$cnlr.median[-1], 0)
  # mad of cnlr noise
  cnlr.mad <- mad(jseg$cnlr - rep(focalout$cnlr.median, focalout$num.mark))
  # segments that show focal changes have big jump in cnlr.median
  focalout$focal <- 1*(focalout$cnlr.median > pmax(cnlr.med.l, cnlr.med.r)+3*cnlr.mad) + 1*(focalout$cnlr.median < pmin(cnlr.med.l, cnlr.med.r)-3*cnlr.mad)
  # get the segments for the specified cval
  nsegs <- 0
  for (i in 1:nchr) {
    seg.widths <- diff(prune.cpt.tree(x$seg.tree[[i]], cval))
    jseg$seg[jseg$chrom==chrs[i]] <- nsegs + rep(1:length(seg.widths), seg.widths)
    nsegs <- nsegs + length(seg.widths)
  }
  # adding the focal change segments - need a jump at the beginning and end
  jseg$seg0 <- jseg$seg # detected segments
  # jump at the beginning (twice the height)
  jseg$seg <- jseg$seg + rep(cumsum(2*focalout$focal), focalout$num.mark)
  # drop back for the focal segment to get the steps right
  jseg$seg <- jseg$seg - rep(focalout$focal, focalout$num.mark)
  # focal segment could already be in; so change seg indicator
  jseg$seg <- cumsum(c(1, 1*(diff(jseg$seg) > 0)))
  # segment summaries
  out <- jointsegsummary(jseg)
  # cluster the segments
  out <- clustersegs(out, jseg, min.nhet)
  # put in the clustered values for snps
  jseg$segclust[is.finite(jseg$cnlr)] <- rep(out$segclust, out$num.mark)
  # find dipLogR and fit cncf
  if (is.null(dipLogR)) {
    oo <- findDiploidLogR(out, jseg$cnlr)
  } else {
    oo <- list()
    oo$out0 <- "empty"
    oo$dipLogR <- dipLogR
  }
  out <- fitcncf(out, oo$dipLogR, nX)
  c(list(jointseg=jseg, out=out, nX=nX, chromlevels=chromlevels), oo[-1])
}

plotSample <- function(x, emfit=NULL, clustered=FALSE, plot.type=c("em","naive","both","none"), sname=NULL) {
  def.par <- par(no.readonly = TRUE) # save default, for resetting...
  # plot.type
  plot.type <- match.arg(plot.type)
  # layout of multi panel figure
  if (plot.type=="none") layout(matrix(1:2, ncol=1))
  if (plot.type=="em") layout(matrix(rep(1:4, c(9,9,6,1)), ncol=1))
  if (plot.type=="naive") layout(matrix(rep(1:4, c(9,9,6,1)), ncol=1))
  if (plot.type=="both") layout(matrix(rep(1:6, c(9,9,6,1,6,1)), ncol=1))
  par(mar=c(0.25,3,0.25,1), mgp=c(1.75, 0.6, 0), oma=c(3,0,1.25,0))
  # raw data used for joint segmentation
  jseg <- x$jointseg
  # chromosome boundaries
  chrbdry <- which(diff(jseg$chrom) != 0)
  if (missing(emfit)) {
    out <- x$out
    if (plot.type=="em" | plot.type=="both") {
      warning("emfit is missing; plot.type set to naive")
      plot.type <- "naive"
    }
  } else {
    out <- emfit$cncf
    # add the naive tcn, lcn and cf to out
    out$tcn <- x$out$tcn
    out$lcn <- x$out$lcn
    out$cf <- x$out$cf
  }
  # determine which of the cnlr.median & mafR to show
  if (clustered) {
    cnlr.median <- out$cnlr.median.clust
    mafR <- out$mafR.clust
    mafR[is.na(mafR)] <- out$mafR[is.na(mafR)]
  } else {
    cnlr.median <- out$cnlr.median
    mafR <- out$mafR
  }
  mafR <- abs(mafR)
  # chromosome colors
  chrcol <- 1+rep(out$chr-2*floor(out$chr/2), out$num.mark)
  nn <- cumsum(table(jseg$chrom[is.finite(jseg$cnlr)]))
  segbdry <- cumsum(c(0,out$num.mark))
  segstart <- segbdry[-length(segbdry)]
  segend <- segbdry[-1]
  # plot the logR data and segment medians
  yvals=jseg$cnlr[is.finite(jseg$cnlr)]
  plot(jseg$cnlr[is.finite(jseg$cnlr)], pch=".", cex=2.5, col = c("grey","lightblue","azure4","slateblue")[chrcol], ylab="log-ratio", xaxt="n", ylim=c(min(yvals,-2)-1,max(yvals,2)+1.5))
  abline(v=chrbdry, lwd=0.25)
  abline(h=median(jseg$cnlr, na.rm=TRUE), col="green2")
  abline(h = x$dipLogR, col = "magenta4")
  segments(segstart, cnlr.median, segend, cnlr.median, lwd=1.75, col=2)
  # plot the logOR data and mafR
  plot(jseg$valor[is.finite(jseg$cnlr)], pch=".", cex=2.5, col = c("grey","lightblue","azure4","slateblue")[chrcol], ylab="log-odds-ratio", ylim=c(-4,4), xaxt="n")
  abline(v=chrbdry, lwd=0.25)
  segments(segstart, sqrt(mafR), segend, sqrt(mafR), lwd=1.75, col=2)
  segments(segstart, -sqrt(mafR), segend, -sqrt(mafR), lwd=1.75, col=2)
  # naive copy number and cellular faction pieces
  cfpalette <- c(colorRampPalette(c("white", "steelblue"))(10),"bisque2")
  if (plot.type=="naive" | plot.type=="both") {
    # plot the estimated copy numbers and cf
    out$tcn[out$tcn > 10] <- 9 + log10(out$tcn[out$tcn > 10])
    ii <- which(out$lcn > 5)
    if (length(ii)>0) out$lcn[ii] <- 5 + log10(out$lcn[ii])
    plot(c(0,length(jseg$cnlr)), c(0,max(out$tcn)), type="n", ylab="copy number (nv)", xaxt="n")
    abline(v=chrbdry, lwd=0.25)
    segments(segstart, out$tcn, segend, out$tcn, lwd=2, col=1)
    segments(segstart, out$lcn, segend, out$lcn, lwd=1.5, col=2)
    # add the cf
    plot(c(0,length(jseg$cnlr)), 0:1, type="n", ylab="", xaxt="n", yaxt="n")
    mtext("cf-nv", side=2, at=0.5, line=0.3, las=2, cex=0.75)
    cfcol <- cfpalette[round(10*out$cf+0.501)]
    rect(segstart, 0, segend, 1, col=cfcol, border=NA)
  }
  # EM copy number and cellular faction pieces
  if (plot.type=="em" | plot.type=="both") {
    # plot the estimated copy numbers and cf
    out$tcn.em[out$tcn.em > 10] <- 9 + log10(out$tcn.em[out$tcn.em > 10])
    ii <- which(out$lcn.em > 5)
    if (length(ii)>0) out$lcn.em[ii] <- 5 + log10(out$lcn.em[ii])
    plot(c(0,length(jseg$cnlr)), c(0,max(out$tcn.em)), type="n", ylab="copy number (em)", xaxt="n")
    abline(v=chrbdry, lwd=0.25)
    segments(segstart, out$tcn.em, segend, out$tcn.em, lwd=2, col=1)
    segments(segstart, out$lcn.em, segend, out$lcn.em, lwd=1.5, col=2)
    # add the cf
    plot(c(0,length(jseg$cnlr)), 0:1, type="n", ylab="", xaxt="n", yaxt="n")
    mtext("cf-em", side=2, at=0.5, line=0.2, las=2, cex=0.75)
    cfcol <- cfpalette[round(10*out$cf.em+0.501)]
    rect(segstart, 0, segend, 1, col=cfcol, border=NA)
  }
  
  # now add the chromosome ticks on x-axis
  chromlevels <- x$chromlevels
  # just make sure chromlevels actually exists
  if (is.null(chromlevels)) chromlevels <- 1:length(nn)
  axis(labels=chromlevels, side=1, at=(nn+c(0,nn[-length(nn)]))/2, cex=0.65)
  mtext(side=1, line=1.75, "Chromosome", cex=0.8)
  if (!missing(sname)) mtext(sname, side=3, line=0, outer=TRUE, cex=0.8)
  par(def.par)  #- reset to default
}

logRlogORspider <- function(cncf, dipLogR=0, nfrac=0.005) {
  rho <- seq(0, 0.95, by=0.01)
  nrho <- length(rho)
  logACR <- logCNR <- matrix(0, nrho, 19)
  # initialize index
  l <- 1
  # one copy loss
  logCNR[,l] <- log2(2*(1-rho) + 1*rho) -1
  logACR[,l] <- log(1/(1-rho))
  # integer copy numbers (clonal)
  for(i in 2:7) {
    for(j in 0:floor(i/2)) {
      l <- l+1
      logCNR[,l] <- log2(2*(1-rho) + i*rho) -1 # base-2
      logACR[,l] <- log(1-rho+(i-j)*rho) - log(1-rho+j*rho)
    }
  }
  
  plot(c(-0.95, 1.8), c(0, 5), type="n", xlab="Expected(logR - dipLogR)", ylab=" Expected(|logOR|)")
  l <- 1; i <-1; j <-0
  linecols <- c("black","cyan3","green3","blue")
  lines(logCNR[,l], logACR[,l], lty=1, col=j+1, lwd=1.25)
  text(logCNR[nrho,l]+0.03, logACR[nrho,l], paste(i,j,sep="-"), cex=0.65)
  for(i in 2:7) {
    for(j in 0:floor(i/2)) {
      l <- l+1
      lines(logCNR[,l], logACR[,l], lty=i-1, col=linecols[j+1], lwd=1.25)
      text(logCNR[nrho,l]+0.03, logACR[nrho,l], paste(i,j,sep="-"), cex=0.65)
    }
  }
  
  nsnps <- sum(cncf$num.mark)
  nhets <- sum(cncf$nhet)
  ii <- cncf$num.mark > nfrac*nsnps & cncf$nhet > nfrac*nhets
  cex <- 0.3 + 2.7*(cncf$num.mark[ii]/sum(0.1*cncf$num.mark[ii]))
  points(cncf$cnlr.median[ii] - dipLogR, sqrt(abs(cncf$mafR[ii])), cex=cex, col="magenta4", lwd=1.5)
}

############################################################################
PreProcSnpPileup <- function(filename, err.thresh=Inf, del.thresh=Inf,
                             is.TandMN=FALSE) {
  #' PreProcSnpPileup takes a snp-pileup generated pileup file and process it into a data frame format for downstream processing.
  #' @param filename (character) File path to snp-pileup generated pileup file.
  #' @param err.thresh (numeric) Error threshold to be used to filter snp-pileup data frame.
  #' @param del.thresh (numeric) Deletion threshold to be used to filter snp-pileup data frame.
  #' @param is.TandMN (logical) Indicate whether the snp-pilep contains columns for Tumor and matched normals data. Is yes, only those columns are used for filtereing using err.thresh and del.thresh, otherwise, all columns are used.
  #' @return A data drame of pileup depth values filtered against del.thresh and err.thresh values.
  
  pileup <- read.csv(filename, stringsAsFactors=FALSE)
  # remove chr if present in Chrom
  if (pileup$Chromosome[1] == "chr1") {
    pileup$Chromosome <- gsub("chr", "", pileup$Chromosome)
  }
  if (gbuild %in% c("hg19", "hg38", "hg18")) chromlevels <- c(1:22,"X")
  if (gbuild %in% c("mm9", "mm10")) chromlevels <- c(1:19,"X")
  pileup <- pileup[which(pileup$Chromosome %in% chromlevels),]
  
  # if pileup data contains tumor and matched normal data, use those columns
  #  to filter against err.thresh and del.thresh
  if (is.TandMN) {
  err.columns <- colnames(pileup)[grep("^File[0-9]+E$", colnames(pileup))][1:2]
  del.columns <- colnames(pileup)[grep("^File[0-9]+D$", colnames(pileup))][1:2]
  
  # remove loci where errors and deletions exceed thresholds
  select.loci <- apply(
    cbind(apply(pileup[err.columns], 2, function(x) x<=err.thresh),
          apply(pileup[del.columns], 2, function(x) x<=del.thresh)),
    1, all)
  
  # select loci in pileup data and skip identifiers
  pileup.select <- pileup[select.loci,]
  }
  else {
    pileup.select <- pileup
  }
  
  # retain genomic coordinates 
  pileup.select.key <- paste(pileup.select$Chromosome, pileup.select$Position, sep=":")
  
  # calculate total depth for each samples at all loci
  for(i in 1:((ncol(pileup.select)-4)/4)){
    temp <- paste0("File", i, "DP")
    tempR <- paste0("File", i, "R")
    tempA <- paste0("File", i, "A")
    pileup.select[,temp] <- pileup.select[,tempR] + pileup.select[,tempA]
  }
  pileup.select<- cbind(key=pileup.select.key, 
                        pileup.select)
  
  return(pileup.select)
}

###########################################################################
FindBestNormalParameters <- function(TumorLoess, TumorPileup,
                                     ReferenceLoess=NULL, ReferencePileup=NULL,
                                     MinOverlap=0.90, matchedNormalforX = FALSE) {
  #' FindBestNormalParameters takes takes a facets2n generated tumor loess object and snp-pileup generated pileup file, and optional similar files for reference normals, and returns the pileup data for the best normal for T/N CNLR.
  #' @param TumorLoess (matrix) A facets2n generated TumorLoess matrix with header and span values in the first row.
  #' @param TumorPileup (data frame) snp-pileup generated pileup data frame with sample columns that match with the TumorLoess object.
  #' @param ReferenceLoess (matrix) A ReferenceLoess matrix with a header and span values in the first row.
  #' @param ReferencePileupFile (data frame) A snp-pileup generated pileup data frame with sample columns that match with the ReferenceLoess object.
  #' @param MinOverlap (numeric) A numeric between 0 and 1 that denotes the fraction overlap of loci between TumorLoess and the optional ReferenceLoess
  #' @param matchedNormalforX (logical) Force select matched normal for normalization in ChrX.
  #' @return A list of data frame with pileup depth values of Tumor, matched Normal, and a best unmatched normal, and the associated span values.
  
  TumorLoess.span <- TumorLoess[1,]
  TumorLoess <- as.data.frame(TumorLoess[-1,])
  colnames(TumorLoess) <- c("key", colnames(TumorLoess)[-1])
  
  if (!is.null(ReferencePileup)) {
    if (is.null(ReferenceLoess)) {
      ReferenceLoess <- MakeLoessObject(ReferencePileup)
    }
    colnames(ReferenceLoess) <- gsub("File", "RefFile", colnames(ReferenceLoess))
    ReferenceLoess.span <- ReferenceLoess[1,]
    ReferenceLoess <- as.data.frame(ReferenceLoess[-1,])
    colnames(ReferenceLoess) <- c("key", colnames(ReferenceLoess)[-1])
    
    common.loci <- intersect(TumorLoess$key, ReferenceLoess$key)
    if (length(common.loci) / max(length(TumorLoess$key), 
                                  length(ReferenceLoess$key)) < MinOverlap ) {
      warning(sprintf("Overlap of loci between the two Loess dataframes\
           is less than defined MinOverlap fraction of %s\n", MinOverlap))
      
    }
    combined.loess <- cbind(
      TumorLoess[which(TumorLoess$key %in% common.loci),],
      ReferenceLoess[which(ReferenceLoess$key %in% common.loci),][,-1]
    )
    combined.span <- c(TumorLoess.span, ReferenceLoess.span[-1])
    }
  else {
    combined.loess <- TumorLoess
    combined.span <- TumorLoess.span
    common.loci <- TumorLoess$key
  }

  # Assumption: First column of data is the key,
  #  Second column belongs to the Tumor sample
  #  Third column belongs to the Normal sample
  TumorIdentifier <- colnames(combined.loess)[3]
  MatchedNormalIdentifier <- colnames(combined.loess)[2]
  
  #identify probes on ChrX for separate processing
  x.idx <- as.vector(grep('^X\\:', combined.loess$key))
  x.idx.values <- as.vector(grep('^X\\:', combined.loess$key, value = T))

  
  #calculate noise of tumor against normals for autosomes and ChrX seperately
  noiseAuto <- do.call('rbind',list(apply(combined.loess[-x.idx,-c(1,3), drop=F],2,function(column){
    lr = log2(as.numeric(levels(combined.loess[-x.idx,3]))[combined.loess[-x.idx,3]]) - 
      log2(as.numeric(column))
    return(sum(lr^2, na.rm=T));
  })));
  
  #pick the normals that minimize noise
  best_normAuto <- colnames(noiseAuto)[which(noiseAuto == min(noiseAuto))][1]
  
  if(matchedNormalforX) {
    best_normX <- MatchedNormalIdentifier
  }
  else {
    noiseX <- do.call('rbind',list(apply(combined.loess[x.idx,-c(1,3), drop=F],2,function(column){
      lr = log2(as.numeric(levels(combined.loess[x.idx,3]))[combined.loess[x.idx,3]]) - 
        log2(as.numeric(column))
      return(sum(lr^2, na.rm=T));
    })));
    
    best_normX <- colnames(noiseX)[which(noiseX == min(noiseX))][1]
  }
  
  message(sprintf("Best normal for autosomes: %s\nBest normal for ChrX: %s\n", 
                  best_normAuto, best_normX))
  
  # if best normal is a reference normal, we need the reference pileup
  if(any(grepl("^Ref", c(best_normAuto, best_normX)))) {
    colnames(ReferencePileup) <- gsub("File", "RefFile", colnames(ReferencePileup))
  }
  
  if(best_normAuto %in% names(TumorLoess)) {
    best_normAuto.dp <- TumorPileup[(TumorPileup$key %in% setdiff(common.loci, x.idx.values)), best_normAuto]
  }
  else {
    best_normAuto.dp <- ReferencePileup[
                           (ReferencePileup$key %in% setdiff(common.loci, x.idx.values)), best_normAuto]
  }

  if(best_normX %in% names(TumorLoess)) {
    best_normX.dp <- TumorPileup[(TumorPileup$key %in% x.idx.values), best_normX]
  }
  else {
    best_normX.dp <- ReferencePileup[
      (ReferencePileup$key %in% x.idx.values), best_normX]
  }


  rcmat <- cbind(TumorPileup[(TumorPileup$key %in% c(setdiff(common.loci, x.idx.values), x.idx.values)), 
                             c("Chromosome", "Position", "File1DP", "File1R", "File2DP", "File2R")],
                 UMN.dp=c(best_normAuto.dp, best_normX.dp))
  colnames(rcmat) <- c("Chromosome", "Position", "NOR.DP", "NOR.RD", "TUM.DP", "TUM.RD", "UMN.DP")
  return(list("rcmat"=rcmat,
              "spanT"=as.numeric(combined.span[TumorIdentifier]), # Assume that tumor data is always in the third column as expected
              "spanA"=as.numeric(combined.span[which(colnames(combined.loess) %in% best_normAuto)]),
              "spanX"=as.numeric(combined.span[which(colnames(combined.loess) %in% best_normX)])
  )
  )
}

######################################################################
MakeLoessObject <- function(pileup, write.loess=FALSE, outfilepath="./loess.txt", is.TandMN = FALSE) {
  
  #' MakeLoessObject takes a pipleup file generated by snp-pileup and generates a loess/lowess object, which is also optinally written into an output file.
  #' @param pileup (data frame) A data franme of snp-pileup generated depth.
  #' @param write.loess (logical) Write loess object into file, instead of returning it as a matrix?
  #' @param outfilepath (character) Filepath for writing loess object.
  #' @param is.TandMN (logical) Indicate whether the snp-pilep contains columns for Tumor and matched normals data. Is yes, only those columns are used for filtereing using err.thresh and del.thresh, otherwise, all columns are used.
  #' @return A dataframe of loess normalized values for all input samples against filtered loci or None, if the loess normalized value is to be written to an output file.
    
  # read pileup data and select rows based on used-defined err and del thresholds
  pileup.select <- pileup

  pileup.select.dp <- pileup.select[,grep(
    paste(c("^key$", "^Chromosome$", "^Position$", "^File.*DP$"),collapse="|"), colnames(pileup.select))]
  if (is.TandMN) { 
    pileup.select.dp$medianDP<- apply(
      pileup.select.dp[,grep("File.*DP", colnames(pileup.select.dp))][,-c(2), drop=F], 1, median, na.rm=T)
    pileup.select.dp$q25<- apply(
      pileup.select.dp[,grep("File.*DP", colnames(pileup.select.dp))][,-c(2), drop=F], 1, quantile, probs=0.25, na.rm=T)
  }
  else {
    pileup.select.dp$medianDP<- apply(
      pileup.select.dp[,grep("File.*DP", colnames(pileup.select.dp))], 1, median, na.rm=T)
    pileup.select.dp$q25<- apply(
      pileup.select.dp[,grep("File.*DP", colnames(pileup.select.dp))], 1, quantile, probs=0.25, na.rm=T)
  }
  

  pileup.select.dp <- pileup.select.dp[
      which(pileup.select.dp$q25>quantile(pileup.select.dp$medianDP, 0.1)),]
  
  pileup.select.dp <- subset(pileup.select.dp, select=-c(q25, medianDP))

  gcout <- subset(pileup.select.dp, select=c(Chromosome, Position))
  gcout$gcpct <- rep(NA_real_, nrow(gcout))
  
  for (i in c(1:22,'X')) {
    ii <- which(gcout$Chromosome==i)
    if (length(ii) > 0) {
      gcout$gcpct[ii] <- getGCpct(i, gcout$Position[ii], gbuild)
    }
  }
  gcout$key <-  paste(gcout$Chromosome, gcout$Position, sep = ":")
  
  #remove positions near centromeres, where we don't calculate GCpct
  gcout <-gcout[!is.na(gcout$gcpct),]
  #subset counts dfs to those with gc calc
  pileup.select.dp <- pileup.select.dp[which(pileup.select.dp$key %in% gcout$key),]

  #add gcpct values to the count file
  pileup.select.dp$gcpct<-gcout[match(pileup.select.dp$key, gcout$key),"gcpct"]
  
  gc.bias <- pileup.select.dp$gcpct
  
  #determine span values for lowess normalization
  span.fits <- do.call('rbind',list(
    apply(subset(pileup.select.dp, select= -c(Chromosome, Position, key, gcpct)),2,function(column){
    column_sqrt<-sqrt(column)
    testspan <- function(spanvalue){  #change this to get span values seperately for auto, X?
      loess.obj<-lowess(gc.bias, column_sqrt,f=spanvalue);
      jj <- match(pileup.select.dp$gcpct, loess.obj$x)
      fit <- loess.obj$y[jj]#Calculation of the loess fit for each spanvalue
      normalized<-column_sqrt-fit+median(column_sqrt) #Data normalized for each spanvalue
      
      loess.obj2<-lowess(gc.bias,normalized,f=spanvalue);
      fit2 <- loess.obj2$y  #The "fit" of each normalized data point - the result gives the flat-ish line
      spanvar <- var(fit2,na.rm=TRUE) #Calculate the variance to find the flattest line after fitting
      return(round(spanvar,5));
    }
    optimize.obj <-	optimize(testspan,interval=c(0.1,0.9),maximum=F);  #change to 0.2, 0.8?
    return(c('min'=optimize.obj$minimum,'obj'=optimize.obj$objective));
  })));
  
  span.fits <- t(span.fits)
  
  pileup.select.dp.lowess <- do.call('cbind',lapply(seq(1,ncol(pileup.select.dp)-4,1),function(i){
    column_sqrt <- sqrt(pileup.select.dp[,grep("File.*DP", colnames(pileup.select.dp))][,i])
    loess.obj <-lowess(gc.bias, column_sqrt,f=span.fits[i,'min']);
    jj <- match(pileup.select.dp$gcpct, loess.obj$x)
    fit <- loess.obj$y[jj]
    normalized <- (column_sqrt-fit+median(column_sqrt))/(median(column_sqrt[which(column_sqrt != 0)]));
    return(normalized);
  }));
  
  colnames(pileup.select.dp.lowess) <- setdiff(
    colnames(pileup.select.dp), c("Chromosome", "Position", "key", "gcpct"))
  
  pileup.select.dp.lowess <- cbind(key=paste0(pileup.select.dp$Chromosome, ":",
                                              pileup.select.dp$Position), pileup.select.dp.lowess)
  
  # add span values as the first row
  pileup.select.dp.lowess <- rbind(c("span", span.fits[,"min"]),as.matrix(pileup.select.dp.lowess))
  
  if(write.loess) {
    write.table(pileup.select.dp.lowess, file=outfilepath, sep="\t", quote=F, col.names=T, row.names=F)
  }
  else {
    return(pileup.select.dp.lowess)
  }
}
