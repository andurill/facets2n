readSnpMatrix <- function(filename, skip=0L, err.thresh=Inf, del.thresh=Inf, 
                          perl.pileup=FALSE, MandUnormal=FALSE, spanT=0.2,
                          spanA=0.2, spanX=0.2, gbuild="hg19", 
                          ReferecePileupName=NULL, ReferenceLoess=NULL,
                          MinOverlap=0.95) {
  # could have been generated by original VES snp-pileup.pl code (perl)
  if (perl.pileup) {
    rcmat <- scan(filename, what=list(Chromosome="", Position=0, 
                                      NOR.DP=0, NOR.RD=0, TUM.DP=0, 
                                      TUM.RD=0), skip=skip)
    if (rcmat$Chromosome[1] == "chr1") {
      rcmat$Chromosome <- gsub("chr","",rcmat$Chromosome)
    }
    rcmat <- as.data.frame(rcmat, stringsAsFactors=FALSE)
  }
  else {
    # read the read count matrix generated by snp-pileup.cpp code
    pileup <- PreProcSnpPileup(filename, err.thresh=Inf, 
                               del.thresh=Inf, TandMN.filter=TRUE)
    #Grab Chromosome and Position from pileup
    rcmat <- pileup[, 1:2]
    #Calculate Tumor and Normal depth from pileup
    rcmat$NOR.DP <- pileup$File1R + pileup$File1A
    rcmat$NOR.RD <- pileup$File1R
    rcmat$TUM.DP <- pileup$File2R + pileup$File2A
    rcmat$TUM.RD <- pileup$File2R
    #Select loci, Tumor and Normal Depth
    rcmat <- subset(rcmat, select=c(Chromosome, Position, NOR.DP, NOR.RD, TUM.DP, TUM.RD))
    
    
    if (MandUnormal){
      rcmat$key = paste(rcmat$Chromosome, rcmat$Position, sep=":")
      tumor.loess <- MakeLoessObject(filename, TandMN.filter=T)
      ReferencePileup <- PreProcSnpPileup(filename, err.thresh=Inf,
                                          del.thresh=Inf)
      BestNormalParams <- FindBestNormalParameters(
        tumor.loess,
        ReferenceLoess,
        MinOverlap
      )
      # get loci/coordinates used for loess normalization
      x.idx <- grep("^X\\:", BestNormalParams$select.loci)
      autosome.idx <- grep("^X\\:", BestNormalParams$select.loci, invert = TRUE)
      
      best_norm.dp <- ifelse(best_normAuto %in% names(pileup),
                             pileup[c(autosome.idx, x.idx), best_normAuto],
                             ReferencePileup[c(autosome.idx, x.idx), best_normAuto])
      
      rmcat_new <- cbind(rcmat[c(autosome.idx, x.idx),], UMN.DP=best_norm.dp)
      rcmat <- subset(rcmat_new, select=c(Chromosome, Position, NOR.DP, NOR.RD, TUM.DP, TUM.RD, UMN.DP))
      return(list("rcmat"=rcmat, "spanT"=BestNormalParams$spanT, 
                  "spanA"=BestNormalParams$spanA, "spanX"=BestNormalParams$spanX))
    }
    else{
      return(rcmat)
    }
  }
}


preProcSample <- function(rcmat, ndepth=35, het.thresh=0.25, snp.nbhd=250, cval=25, deltaCN=0, gbuild=c("hg19", "hg38", "hg18", "mm9", "mm10"), hetscale=TRUE, unmatched=FALSE, MandUnormal=FALSE, ndepthmax=5000, spanT=0.2, spanA=0.2, spanX=0.2) {
  gbuild <- match.arg(gbuild)
  # integer value for chromosome X depends on the genome
  if (gbuild %in% c("hg19", "hg38", "hg18")) nX <- 23
  if (gbuild %in% c("mm9", "mm10")) nX <- 20
  pmat <- procSnps(rcmat, ndepth, het.thresh, snp.nbhd, gbuild, unmatched, ndepthmax)
  dmat <- counts2logROR(pmat[pmat$rCountT>0,], gbuild, unmatched, MandUnormal, 0.2, spanT,spanA, spanX)
  tmp <- segsnps(dmat, cval, hetscale, deltaCN)
  out <- list(pmat=pmat, gbuild=gbuild, nX=nX)
  c(out, tmp)
}


procSample <- function(x, cval=150, min.nhet=15, dipLogR=NULL) {
  # ensure availability of seg.tree
  if (is.null(x$seg.tree)) stop("seg.tree is not available")
  # get the numeric value of chromosome X
  nX <- x$nX
  # make sure that original cval is smaller than current one
  cval.fit <- attr(x$seg.tree, "cval")
  if (cval.fit > cval) stop("original fit used cval = ", cval.fit)
  # jointseg etc
  jseg <- x$jointseg
  jseg <- jseg[is.finite(jseg$cnlr),]
  # chromosomes with data and their counts
  chrs <- x$chromlevels
  nchr <- length(chrs)
  # get chromlevels from chrs
  if (x$gbuild %in% c("hg19", "hg38", "hg18")) chromlevels <- c(1:22,"X")[chrs]
  if (x$gbuild %in% c("mm9", "mm10")) chromlevels <- c(1:19,"X")[chrs]
  # get the segment summary for the fit in seg.tree
  nsegs <- 0
  for (i in 1:nchr) {
    seg.widths <- diff(c(0, sort(unique(x$seg.tree[[i]][,3]))))
    jseg$seg[jseg$chrom==chrs[i]] <- nsegs + rep(1:length(seg.widths), seg.widths)
    nsegs <- nsegs + length(seg.widths)
  }
  focalout <- jointsegsummary(jseg)
  # cnlr.median to the left and right
  cnlr.med.l <- c(0, focalout$cnlr.median[-nsegs])
  cnlr.med.r <- c(focalout$cnlr.median[-1], 0)
  # mad of cnlr noise
  cnlr.mad <- mad(jseg$cnlr - rep(focalout$cnlr.median, focalout$num.mark))
  # segments that show focal changes have big jump in cnlr.median
  focalout$focal <- 1*(focalout$cnlr.median > pmax(cnlr.med.l, cnlr.med.r)+3*cnlr.mad) + 1*(focalout$cnlr.median < pmin(cnlr.med.l, cnlr.med.r)-3*cnlr.mad)
  # get the segments for the specified cval
  nsegs <- 0
  for (i in 1:nchr) {
    seg.widths <- diff(prune.cpt.tree(x$seg.tree[[i]], cval))
    jseg$seg[jseg$chrom==chrs[i]] <- nsegs + rep(1:length(seg.widths), seg.widths)
    nsegs <- nsegs + length(seg.widths)
  }
  # adding the focal change segments - need a jump at the beginning and end
  jseg$seg0 <- jseg$seg # detected segments
  # jump at the beginning (twice the height)
  jseg$seg <- jseg$seg + rep(cumsum(2*focalout$focal), focalout$num.mark)
  # drop back for the focal segment to get the steps right
  jseg$seg <- jseg$seg - rep(focalout$focal, focalout$num.mark)
  # focal segment could already be in; so change seg indicator
  jseg$seg <- cumsum(c(1, 1*(diff(jseg$seg) > 0)))
  # segment summaries
  out <- jointsegsummary(jseg)
  # cluster the segments
  out <- clustersegs(out, jseg, min.nhet)
  # put in the clustered values for snps
  jseg$segclust[is.finite(jseg$cnlr)] <- rep(out$segclust, out$num.mark)
  # find dipLogR and fit cncf
  if (is.null(dipLogR)) {
    oo <- findDiploidLogR(out, jseg$cnlr)
  } else {
    oo <- list()
    oo$out0 <- "empty"
    oo$dipLogR <- dipLogR
  }
  out <- fitcncf(out, oo$dipLogR, nX)
  c(list(jointseg=jseg, out=out, nX=nX, chromlevels=chromlevels), oo[-1])
}

plotSample <- function(x, emfit=NULL, clustered=FALSE, plot.type=c("em","naive","both","none"), sname=NULL) {
  def.par <- par(no.readonly = TRUE) # save default, for resetting...
  # plot.type
  plot.type <- match.arg(plot.type)
  # layout of multi panel figure
  if (plot.type=="none") layout(matrix(1:2, ncol=1))
  if (plot.type=="em") layout(matrix(rep(1:4, c(9,9,6,1)), ncol=1))
  if (plot.type=="naive") layout(matrix(rep(1:4, c(9,9,6,1)), ncol=1))
  if (plot.type=="both") layout(matrix(rep(1:6, c(9,9,6,1,6,1)), ncol=1))
  par(mar=c(0.25,3,0.25,1), mgp=c(1.75, 0.6, 0), oma=c(3,0,1.25,0))
  # raw data used for joint segmentation
  jseg <- x$jointseg
  # chromosome boundaries
  chrbdry <- which(diff(jseg$chrom) != 0)
  if (missing(emfit)) {
    out <- x$out
    if (plot.type=="em" | plot.type=="both") {
      warning("emfit is missing; plot.type set to naive")
      plot.type <- "naive"
    }
  } else {
    out <- emfit$cncf
    # add the naive tcn, lcn and cf to out
    out$tcn <- x$out$tcn
    out$lcn <- x$out$lcn
    out$cf <- x$out$cf
  }
  # determine which of the cnlr.median & mafR to show
  if (clustered) {
    cnlr.median <- out$cnlr.median.clust
    mafR <- out$mafR.clust
    mafR[is.na(mafR)] <- out$mafR[is.na(mafR)]
  } else {
    cnlr.median <- out$cnlr.median
    mafR <- out$mafR
  }
  mafR <- abs(mafR)
  # chromosome colors
  chrcol <- 1+rep(out$chr-2*floor(out$chr/2), out$num.mark)
  nn <- cumsum(table(jseg$chrom[is.finite(jseg$cnlr)]))
  segbdry <- cumsum(c(0,out$num.mark))
  segstart <- segbdry[-length(segbdry)]
  segend <- segbdry[-1]
  # plot the logR data and segment medians
  yvals=jseg$cnlr[is.finite(jseg$cnlr)]
  plot(jseg$cnlr[is.finite(jseg$cnlr)], pch=".", cex=2.5, col = c("grey","lightblue","azure4","slateblue")[chrcol], ylab="log-ratio", xaxt="n", ylim=c(min(yvals,-2)-1,max(yvals,2)+1.5))
  abline(v=chrbdry, lwd=0.25)
  abline(h=median(jseg$cnlr, na.rm=TRUE), col="green2")
  abline(h = x$dipLogR, col = "magenta4")
  segments(segstart, cnlr.median, segend, cnlr.median, lwd=1.75, col=2)
  # plot the logOR data and mafR
  plot(jseg$valor[is.finite(jseg$cnlr)], pch=".", cex=2.5, col = c("grey","lightblue","azure4","slateblue")[chrcol], ylab="log-odds-ratio", ylim=c(-4,4), xaxt="n")
  abline(v=chrbdry, lwd=0.25)
  segments(segstart, sqrt(mafR), segend, sqrt(mafR), lwd=1.75, col=2)
  segments(segstart, -sqrt(mafR), segend, -sqrt(mafR), lwd=1.75, col=2)
  # naive copy number and cellular faction pieces
  cfpalette <- c(colorRampPalette(c("white", "steelblue"))(10),"bisque2")
  if (plot.type=="naive" | plot.type=="both") {
    # plot the estimated copy numbers and cf
    out$tcn[out$tcn > 10] <- 9 + log10(out$tcn[out$tcn > 10])
    ii <- which(out$lcn > 5)
    if (length(ii)>0) out$lcn[ii] <- 5 + log10(out$lcn[ii])
    plot(c(0,length(jseg$cnlr)), c(0,max(out$tcn)), type="n", ylab="copy number (nv)", xaxt="n")
    abline(v=chrbdry, lwd=0.25)
    segments(segstart, out$tcn, segend, out$tcn, lwd=2, col=1)
    segments(segstart, out$lcn, segend, out$lcn, lwd=1.5, col=2)
    # add the cf
    plot(c(0,length(jseg$cnlr)), 0:1, type="n", ylab="", xaxt="n", yaxt="n")
    mtext("cf-nv", side=2, at=0.5, line=0.3, las=2, cex=0.75)
    cfcol <- cfpalette[round(10*out$cf+0.501)]
    rect(segstart, 0, segend, 1, col=cfcol, border=NA)
  }
  # EM copy number and cellular faction pieces
  if (plot.type=="em" | plot.type=="both") {
    # plot the estimated copy numbers and cf
    out$tcn.em[out$tcn.em > 10] <- 9 + log10(out$tcn.em[out$tcn.em > 10])
    ii <- which(out$lcn.em > 5)
    if (length(ii)>0) out$lcn.em[ii] <- 5 + log10(out$lcn.em[ii])
    plot(c(0,length(jseg$cnlr)), c(0,max(out$tcn.em)), type="n", ylab="copy number (em)", xaxt="n")
    abline(v=chrbdry, lwd=0.25)
    segments(segstart, out$tcn.em, segend, out$tcn.em, lwd=2, col=1)
    segments(segstart, out$lcn.em, segend, out$lcn.em, lwd=1.5, col=2)
    # add the cf
    plot(c(0,length(jseg$cnlr)), 0:1, type="n", ylab="", xaxt="n", yaxt="n")
    mtext("cf-em", side=2, at=0.5, line=0.2, las=2, cex=0.75)
    cfcol <- cfpalette[round(10*out$cf.em+0.501)]
    rect(segstart, 0, segend, 1, col=cfcol, border=NA)
  }
  
  # now add the chromosome ticks on x-axis
  chromlevels <- x$chromlevels
  # just make sure chromlevels actually exists
  if (is.null(chromlevels)) chromlevels <- 1:length(nn)
  axis(labels=chromlevels, side=1, at=(nn+c(0,nn[-length(nn)]))/2, cex=0.65)
  mtext(side=1, line=1.75, "Chromosome", cex=0.8)
  if (!missing(sname)) mtext(sname, side=3, line=0, outer=TRUE, cex=0.8)
  par(def.par)  #- reset to default
}

logRlogORspider <- function(cncf, dipLogR=0, nfrac=0.005) {
  rho <- seq(0, 0.95, by=0.01)
  nrho <- length(rho)
  logACR <- logCNR <- matrix(0, nrho, 19)
  # initialize index
  l <- 1
  # one copy loss
  logCNR[,l] <- log2(2*(1-rho) + 1*rho) -1
  logACR[,l] <- log(1/(1-rho))
  # integer copy numbers (clonal)
  for(i in 2:7) {
    for(j in 0:floor(i/2)) {
      l <- l+1
      logCNR[,l] <- log2(2*(1-rho) + i*rho) -1 # base-2
      logACR[,l] <- log(1-rho+(i-j)*rho) - log(1-rho+j*rho)
    }
  }
  
  plot(c(-0.95, 1.8), c(0, 5), type="n", xlab="Expected(logR - dipLogR)", ylab=" Expected(|logOR|)")
  l <- 1; i <-1; j <-0
  linecols <- c("black","cyan3","green3","blue")
  lines(logCNR[,l], logACR[,l], lty=1, col=j+1, lwd=1.25)
  text(logCNR[nrho,l]+0.03, logACR[nrho,l], paste(i,j,sep="-"), cex=0.65)
  for(i in 2:7) {
    for(j in 0:floor(i/2)) {
      l <- l+1
      lines(logCNR[,l], logACR[,l], lty=i-1, col=linecols[j+1], lwd=1.25)
      text(logCNR[nrho,l]+0.03, logACR[nrho,l], paste(i,j,sep="-"), cex=0.65)
    }
  }
  
  nsnps <- sum(cncf$num.mark)
  nhets <- sum(cncf$nhet)
  ii <- cncf$num.mark > nfrac*nsnps & cncf$nhet > nfrac*nhets
  cex <- 0.3 + 2.7*(cncf$num.mark[ii]/sum(0.1*cncf$num.mark[ii]))
  points(cncf$cnlr.median[ii] - dipLogR, sqrt(abs(cncf$mafR[ii])), cex=cex, col="magenta4", lwd=1.5)
}

############################################################################
PreProcSnpPileup <- function(filename, err.thresh=Inf, del.thresh=Inf,
                             TandMN.filter=FALSE) {
  pileup <- read.csv(filename, stringsAsFactors=FALSE)
  # remove chr if present in Chrom
  if (pileup$Chromosome[1] == "chr1") {
    pileup$Chromosome <- gsub("chr", "", pileup$Chromosome)
  }
  if (gbuild %in% c("hg19", "hg38", "hg18")) chromlevels <- c(1:22,"X")
  if (gbuild %in% c("mm9", "mm10")) chromlevels <- c(1:19,"X")
  pileup <- pileup[which(pileup$Chromosome %in% chromlevels),]
  err.columns <- ifelse(TandMN.filter,
                        colnames(pileup)[grep("^File[0-9]+E$", colnames(pileup))][1:2],
                        colnames(pileup)[grep("^File[0-9]+E$", colnames(pileup))])
  del.columns <- ifelse(TandMN.filter,
                        colnames(pileup)[grep("^File[0-9]+D$", colnames(pileup))][1:2],
                        colnames(pileup)[grep("^File[0-9]+D$", colnames(pileup))])
  
  # remove loci where errors and deletions exceed thresholds
  select.loci <- apply(
    cbind(apply(pileup[err.columns], 2, function(x) x<=err.thresh),
          apply(pileup[del.columns], 2, function(x) x<=del.thresh)),
    1, all)
  
  # select loci in pileup data and skip identifiers
  pileup.select <- pileup[select.loci,]
  
  # retain genomic coordinates 
  pileup.select.key <- paste(pileup.select$Chromosome, pileup.select$Position, sep=":")
  pileup.select.Chromosome <- pileup.select$Chromosome
  pileup.select.Position <- pileup.select$Position
  # remove genomic coordinates and info columns
  #pileup.select <- pileup.select[,5:ncol(pileup.select)]
  
  # calculate total depth for each samples at all loci
  for(i in 1:((ncol(pileup.select)-4)/4)){
    temp <- paste('File', i, "DP", sep="")
    tempR <- paste("File", i, "R", sep="")
    tempA <- paste("File", i, "A", sep="")
    pileup.select[,temp] <- pileup.select[,tempR] + pileup.select[,tempA]
  }
  pileup.select<- cbind(key=pileup.select.key, 
                        #Chromosome=pileup.select.Chromosome,
                        #Position=pileup.select.Position,
                        pileup.select)
  
  return(pileup.select)
}

###########################################################################
FindBestNormalParameters <- function(TumorLoess, TumorPileup,
                                     ReferenceLoessFile=NULL, ReferencePileupFile=NULL,
                                     MinOverlap=0.95) {
  
  TumorLoess.span <- TumorLoess[1,]
  TumorLoess <- as.data.frame(TumorLoess[-1,])
  colnames(TumorLoess) <- c("key", colnames(TumorLoess)[-1])
  
  if (!is.null(ReferenceLoessFile)) {
    #combine loess dataframes and retain the data for the
    # intersection of loci between the two datadrames.
    ReferenceLoess <- as.matrix(read.csv(ReferenceLoessFile, sep="\t",, 
                               stringsAsFactors=FALSE, header=T))
    ReferenceLoess.span <- ReferenceLoess[1,]
    ReferenceLoess <- as.data.frame(ReferenceLoess[-1,])
    colnames(ReferenceLoess) <- c("key", colnames(ReferenceLoess)[-1])
    
    common.loci <- intersect(TumorLoess$key, ReferenceLoess$key)
    if (length(common.loci) / max(length(TumorLoess$key), 
                                  length(ReferenceLoess$key)) < MinOverlap ) {
      stop("Percentage overlap of loci between the two Loess dataframes\
           is less than defined MinOverlap!")
    }

    # Store original reference loess colnames and append
    #  tafs to the column names.
    ReferenceLoess.cols <- colnames(ReferenceLoess)
    colnames(ReferenceLoess) <- gsub("File", "RefFile", colnames(ReferenceLoess))
    combined.loess <- cbind(
      TumorLoess[which(TumorLoess$key %in% common.loci),],
      ReferenceLoess[which(ReferenceLoess$key %in% common.loci),][,-1]
    )
    combined.span <- c(TumorLoess.span, ReferenceLoess.span[-1])
    }
  else {
    combined.loess <- TumorLoess
    combined.span <- c(TumorLoess.span[1,])
  }
  
  #Assumption: First column of data is the key,
  #  Second column belongs to the Tumor sample
  #  Third column belongs to the Normal sample
  TumorIdentifier <- colnames(combined.loess)[2]
  MatchedNormalIdentifier <- colnames(combined.loess)[3]
  
  #identify probes on ChrX for separate processing
  x.idx <- as.vector(grep('^X\\:', combined.loess$key))
  x.idx.values <- as.vector(grep('^X\\:', combined.loess$key, value = T))
  
  # Remove key and Tumor loess column
  normal.loess <- combined.loess[-c(1:2)]
  
  #calculate noise of tumor against normals for autosomes and ChrX seperately
  noiseAuto <- do.call('rbind',list(apply(normal.loess[-x.idx,],2,function(column){
    lr = log2(as.numeric(combined.loess[-x.idx,2])) - log2(as.numeric(column))
    return(sum(lr^2, na.rm=T));
  })));
  
  noiseX <- do.call('rbind',list(apply(normal.loess[x.idx,],2,function(column){
    lr = log2(as.numeric(combined.loess[x.idx,2])) - log2(as.numeric(column))
    return(sum(lr^2, na.rm=T));
  })));
  
  #pick the normals that minimize noise
  best_normAuto <- colnames(noiseAuto)[which(noiseAuto == min(noiseAuto))][1]
  best_normX <- colnames(noiseX)[which(noiseX == min(noiseX))][1]
  
  message(sprintf("Best normal for autosomes: %s\nBest normal for ChrX: %s\n", 
                  best_normAuto, best_normX))
  # if best normal is a refernce normal, we need the reference pileup
  if(any(grepl("^Ref", c(best_normAuto, best_normX)))) {
    ReferencePileup <- PreProcSnpPileup(ReferencePileupFile)
    colnames(ReferencePileup) <- gsub("File", "RefFile", colnames(ReferencePileup))
  }
  
  if(best_normAuto %in% names(TumorLoess)) {
    best_normAuto.dp <- TumorPileup[(TumorPileup$key %in% setdiff(common.loci, x.idx.values)), best_normAuto]
  }
  else {
    best_normAuto.dp <- ReferencePileup[
                           (ReferencePileup$key %in% setdiff(common.loci, x.idx.values)), best_normAuto]
  }

  if(best_normX %in% names(TumorLoess)) {
    best_normX.dp <- TumorPileup[(TumorPileup$key %in% x.idx.values), best_normX]
  }
  else {
    best_normX.dp <- ReferencePileup[
      (ReferencePileup$key %in% x.idx.values), best_normX]
  }

  best_norm <-cbind(
    key=c(setdiff(common.loci, x.idx.values), x.idx.values),
    UMN.dp=c(best_normAuto.dp, best_normX.dp)
  )
  
  rcmat <- cbind(TumorPileup[(TumorPileup$key %in% c(setdiff(common.loci, x.idx.values), x.idx.values)), 
                             c("Chromosome", "Position", "File2DP", "File2R", "File1DP", "File1R")],
                 UMN.dp=c(best_normAuto.dp, best_normX.dp))
  colnames(rcmat) <- c("Chromosome", "Position", "NOR.DP", "NOR.RD", "TUM.DP", "TUM.RD", "UMN.dp")
  return(list("rcmat"=rcmat,
              "spanT"=as.numeric(combined.span[2]), # Assume that tumor data is always in the second column as expected
              "spanA"=as.numeric(combined.span[which(colnames(combined.loess) %in% best_normAuto)]),
              "spanX"=as.numeric(combined.span[which(colnames(combined.loess) %in% best_normX)])
  )
  )
}


MakeLoessObject <- function(pileupfilepath, err.thresh=Inf, del.thresh=Inf,
                            is.TandMN=FALSE, write.loess=FALSE, outfilepath="./loess.txt") {
  
  #' MakeLoessObject takes a pipleup file generated by snp-pileup
  #' \function and generates a loess/lowess object, which is also optinally written into an output file.
  #' @param pileupfilepath A string indicating file path to snp-pileup generated file.
  #' @param err.thresh A numeric upper error threshold to filter loci in pileup.
  #' @param del.thresh A numeric upper del threshold to filter loci in pileup.
  #' @param TandMN.filter A logical scalar. Does the pileup file include Tumor and Matched normal data as first and second samples, respectively?
  #' @param write.loess A logical scalar. Write loess object into file?
  #' @param outfilepath A string indicating out file path for loess object.
  #' @return A dataframe of loess normalized values for all input samples against filtered loci.
  
  # read pileup data and select rows based on used-defined err and del thresholds
  pileup.select <- PreProcSnpPileup(
    pileupfilepath, err.thresh, del.thresh, is.TandMN)

  pileup.select.key <- pileup.select$key
  pileup.select.Chromosome <- pileup.select$Chromosome
  pileup.select.Position <- pileup.select$Position
  
  # calculate total depth for each samples at all loci
  # for(i in 1:((ncol(pileup.select)-4)/4 + 1)){
  #  temp <- paste('File', i, "DP", sep="")
  #  tempR <- paste("File", i, "R", sep="")
  #  tempA <- paste("File", i, "A", sep="")
  #  pileup.select[,temp] <- pileup.select[,tempR] + pileup.select[,tempA]
  # }
  
  pileup.select.dp <- pileup.select[,grep(
    paste(c("^key$", "^Chromosome$", "^Position$", "^File.*DP$"),collapse="|"), colnames(pileup.select))]

  pileup.select.dp$medianDP<- apply(pileup.select.dp[,grep("DP", colnames(pileup.select.dp))], 1, median, na.rm=T)
  #pileup.select.dp$medianDP<- apply(pileup.select.dp, 1, median, na.rm=T)

  pileup.select.dp$q25<- apply(
    pileup.select.dp[,grep("File.*DP", colnames(pileup.select.dp))], 1, quantile, probs=0.25, na.rm=T)

  #pileup.select.dp$q25<- apply(
  #  subset(pileup.select.dp, select = -c(key, Chromosome, Position, medianDP)), 1, quantile, probs=0.25, na.rm=T)

  
  pileup.select.dp <- pileup.select.dp[
    which(pileup.select.dp$q25>quantile(pileup.select.dp$medianDP, 0.1)),]
  
  

  pileup.select.dp <- subset(pileup.select.dp, select=-c(q25, medianDP))

  

  #pileup.select.dp <- cbind(key=pileup.select.key, 
  #                      Chromosome=pileup.select.Chromosome,
  #                      Position=pileup.select.Position,
  #                      pileup.select.dp)

  
  gcout <- subset(pileup.select.dp, select=c(Chromosome, Position))
  gcout$gcpct <- rep(NA_real_, nrow(gcout))
  
  for (i in c(1:22,'X')) {
    ii <- which(gcout$Chromosome==i)
    if (length(ii) > 0) {
      gcout$gcpct[ii] <- getGCpct(i, gcout$Position[ii], gbuild)
    }
  }
  gcout$key <-  paste(gcout$Chromosome, gcout$Position, sep = ":")
  
  #remove positions near centromeres, where we don't calculate GCpct
  gcout <-gcout[!is.na(gcout$gcpct),]
  #subset counts dfs to those with gc calc
  pileup.select.dp <- pileup.select.dp[which(pileup.select.dp$key %in% gcout$key),]
  #add gcpct values to the count file
  pileup.select.dp$gcpct<-gcout[match(pileup.select.dp$key, gcout$key),"gcpct"]
  
  
  gc.bias <- pileup.select.dp$gcpct
  
  #determine span values for lowess normalization
  span.fits <- do.call('rbind',list(apply(subset(pileup.select.dp, select= -c(Chromosome, Position, key, gcpct)),2,function(column){
    column_sqrt<-sqrt(column);
    testspan <- function(spanvalue){  #change this to get span values seperately for auto, X?
      loess.obj<-lowess(gc.bias, column_sqrt,f=spanvalue);
      jj <- match(pileup.select.dp$gcpct, loess.obj$x)
      fit <- loess.obj$y[jj]#Calculation of the loess fit for each spanvalue
      normalized<-column_sqrt-fit+median(column_sqrt) #Data normalized for each spanvalue
      
      loess.obj2<-lowess(gc.bias,normalized,f=spanvalue);
      #jj=match(unorms.dp$gcpct, loess.obj2$x)
      fit2 <- loess.obj2$y  #The "fit" of each normalized data point - the result gives the flat-ish line
      spanvar <- var(fit2,na.rm=TRUE) #Calculate the variance to find the flattest line after fitting
      return(round(spanvar,5));
    }
    optimize.obj <-	optimize(testspan,interval=c(0.1,0.9),maximum=F);  #change to 0.2, 0.8?
    return(c('min'=optimize.obj$minimum,'obj'=optimize.obj$objective));
  })));
  
  
  span.fits <- t(span.fits);
  
  pileup.select.dp.lowess <- do.call('cbind',lapply(seq(1,ncol(pileup.select.dp)-4,1),function(i){
    column_sqrt <- sqrt(pileup.select.dp[,grep("DP", colnames(pileup.select.dp))][,i]);
    #gc.bias <- unorms.dp$gcpct
    loess.obj <-lowess(gc.bias, column_sqrt,f=span.fits[i,'min']);
    jj <- match(pileup.select.dp$gcpct, loess.obj$x)
    fit <- loess.obj$y[jj]
    normalized <- (column_sqrt-fit+median(column_sqrt))/(median(column_sqrt[which(column_sqrt != 0)]));
    return(normalized);
  }));
  
  colnames(pileup.select.dp.lowess) <- setdiff(
    colnames(pileup.select.dp), c("Chromosome", "Position", "key", "gcpct"))
  
  pileup.select.dp.lowess <- cbind(key=paste0(pileup.select.dp$Chromosome, ":",
                                              pileup.select.dp$Position), pileup.select.dp.lowess)
  
  # add span values as the first row
  pileup.select.dp.lowess <- rbind(c("span", span.fits[,"min"]),as.matrix(pileup.select.dp.lowess))
  
  if(write.loess) {
    write.table(pileup.select.dp.lowess, file=outfilepath, sep="\t", quote=F, col.names=T, row.names=F)
  }
  return(pileup.select.dp.lowess)
}
